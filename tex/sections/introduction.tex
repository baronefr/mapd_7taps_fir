\section{Introduction}
\label{sec:intro}

In this report we discuss the implementation of a Finite Impulse Response (FIR) filter on FPGA board. The ultimate target is to test it as a \emph{low-pass} and \emph{high-pass} filter, using both simulated and real sound samples. A low-pass filter is capable of attenuating signal frequencies above a given threshold (which we call cutoff frequency $f_c$), resulting in frequencies below the threshold to 'pass' through the filtering process. Viceversa, an high-pass filter selects frequencies above the threshold $f_c$ and attenuates lower frequencies.

In the particular case of FIR filters, the output is given by a discrete convolution of the input signal. As we will soon describe better, the output is calculated on a linear combination of $k$ input samples. In this case we say that the filter has $k$ \emph{taps}, or equivalently that filter is of order $k-1$. We have chosen to implement a \emph{7-taps} FIR filter (i.e. an order 6 filter). Generally, the filter qualitative response improves as the order is increased. However, we chose to limit on a small number of taps, so to not unnecessarily increase the complexity of the implementation.

The results have been achieved through various steps. The hardware has been designed in VHDL, using the suite Vivado. This development environment allowed us to simulate the filter long before implementing it on a real circuit. In the discussion we will often see some of those simulations. On the other hand, the test on a real FPGA board required some additional workout, as we need a data exchange interface to feed the input signal samples to the filter and retrieving the output. This task has been carried out with a UART entity built in the implementation, which communicates to a computer via USB serial interface. On the computer client, the data exchange is Python-based.

Finally, we wanted to add some additional features to the implementation. It is possible to change \emph{run-time} the parameters of the FIR filter, without running any additional implementation on Vivado. By default, out filter works as a 30Hz low-pass filter. A switch on the FPGA board allows to change the operative mode of the circuit. When the board is in \emph{programming mode} (switch closed), the FPGA takes the new parameters as integer values through the UART interface. On the computer client, this exchange is managed through a dedicated Python script. When the switch is placed back to the original position (opened), the filter has been reset with the new parameters and is waiting for new data in (i.e. \emph{operative mode}).